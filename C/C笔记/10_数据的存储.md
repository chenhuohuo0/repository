数据的存储

### c语言的数据类型



##### 类型的意义

1.数据类型决定内存空间开辟的大小

2.类型决定看待内存的视角

```c
//不同类型的在内存中的存储方式不同
int a = 10;
float b = 10.0;
```



##### 1.内置类型

char 

int 

long

short

double

float

long long



![image-20230813173053329](C:\Users\cyl\AppData\Roaming\Typora\typora-user-images\image-20230813173053329.png)

**整型家族**

 unsigned int

signed int 

unsigned char

signed char

unsigned short

signed short

unsigned long

signed long

 **浮点型家族**

float

double

**unsigned和signed**

signed最高位当成符号位0正1负

unsigned只有正数



##### 2.构造类型

\>数组类型

```
int arr[10];------>int [5]是它的数据类型
```

\>结构体struct 

\>枚举类型

\>联合类型



##### 3.指针类型



##### 4.空类型

void





### 整型和浮点型在内存中的存储

![image-20230813173053329](C:\Users\cyl\AppData\Roaming\Typora\typora-user-images\image-20230813173053329.png)



##### 原码反码补码

有符号位的整型有三种形式：原码反码补码，正数的原反补相同

**原码**--直接翻译成二进制位

**反码**--符号位不变，其他位按位取反

**补码**--反码+1

```c
int a=20;
//00000000000000000000000000010100 - 原码、反码、补码
int b=-10;
//10000000000000000000000000001010 - 原码
//11111111111111111111111111110101 - 反码
//11111111111111111111111111110110 - 补码
//0xfffffff6
```

**将补码转化16进制在内存中存储    ----->**  32位2进制位总共转化成8个16进制位

![image-20230813175921068](C:\Users\cyl\AppData\Roaming\Typora\typora-user-images\image-20230813175921068.png)

补码可以让加减可以统一运算，无需多余的硬件（CPU只有加法器）

1+（-1）

00000000000000000000000000000001

11111111111111111111111111111111

100000000000000000000000000000000多出一位被截断

00000000000000000000000000000000



##### 练习

```c
char a=-1;
signed char b=-1;
unsigned c=-1;
printf("a=%d b=%d c=%d");//-1 -2 255
//赋值被截断11111111
//以%d输出时发生整型提升，有符号数ab以第一位位符号位补齐11111111111111111111111111111111
//无符号数c默认补零00000000000000000000000011111111
```

```c
char a=-128;
//100000000000000000000010000000 - 原码
//111111111111111111111101111111 - 反码
//111111111111111111111110000000 - 补码
//被截断10000000
//需要打印前发生整型提升，有符号数按符号位补齐
//111111111111111111111110000000
printf("%u\n",a);
//%u打印10进制无符号数，%d打印十进制有符号数
//无符号数补码即是原码111111111111111111111110000000被计算成十进制4294967168

```

![image-20230813192311730](C:\Users\cyl\AppData\Roaming\Typora\typora-user-images\image-20230813192311730.png)

有符号位char256个补码表示的数值如下（正数直接转化成10进制，负数先计算出原码再转换成10进制）

00000000  - 0 

00000001 - 1

00000010 - 2

……

01111111 - 127   

10000000 不能计算原码，被规定成-128

10000001 -> -127

……

11111101 -> -3

11111110 -> -2

11111111 -> -1

![image-20230813202603617](C:\Users\cyl\AppData\Roaming\Typora\typora-user-images\image-20230813202603617.png)

![image-20230813195106477](C:\Users\cyl\AppData\Roaming\Typora\typora-user-images\image-20230813195106477.png)



无符号char最高位不再是符号位

00000000 - 0

00000001 - 1

……

11111111 - 255



```c
int i=-20;
//10000000 00000000 00000000 00010100
//11111111 11111111 11111111 11101011
//11111111 11111111 11111111 11101100 - i补码
unsigned int j=10;
//10000000 00000000 00000000 00001010 - j补码

//11111111 11111111 11111111 11110110 - i+j补码
//11111111 11111111 11111111 11110101 
//10000000 00000000 00000000 00001010 - i+j原码
printf("%d\n",i+j);//-10
```

```c
//死循环预测结果
unsigned int i;
for(i=9;i>=0;i++)
{
    printf("%u\n",i);
}
```

```c
char a[1000];
int i;
for(i=1;i<1000;i++)
{
    a[i]=-1-i;
}
printf("%d",strlen(a));//255
```

```c
//死循环
unsigned char i=0;
for(i=0;i<=255;i++)
{
    printf("%u\n",i):
    //Sleep(100);
}
```



##### 大小端

大端存储：数据低位保存在内存高位，数据高位保存在内存低地址

小端存储：相反

```c
//写一个程序判断当前机器的字节序存储方式
int a=1;
char* p=(char*)&a;
if(*p==1)
    printf("小端\n");
else
    printf("大端\n");

//函数--判断字节序
int bite_order()
{
    int a=1;
    char* p=(char*)&a;
    //小端返回1，大端返回0
    return *p;
}

int main()
{
    int ret=bite_order();
    if(ret==1)
        printf("小端\n");
    else
    	printf("大端\n");
}
```

##### 浮点型的存储

```c
//浮点型存储方式与整型不同
int n=9;
float* p=(float*)&n;
printf("%d\n",n);
printf("%f\n",*p);
*p=9.0;
printf("%d\n",n);
printf("%f\n",*p);
```

![image-20230813211418911](C:\Users\cyl\AppData\Roaming\Typora\typora-user-images\image-20230813211418911.png)

一个浮点数的二进制总是可以化为：(-1)^s\*M\*2^E

例如：9.0 -> 1001.000000 ->  (-1)^0\*1.001*2^3



**IEEE 754规定**：对于32位的浮点数，最高位是符号位s，接着8位是指数位E，剩下23位为有效数字M.对于64位的浮点数，最高位为符号位s，接着11位为E，剩下为M

**M的规定**

M一定可以写成1.xxxxx，所以只存储xxxxx部分

**E的规定**

E是一个unsigned int，如果E为8位，取值范围为0-255，如果E为11位，取值范围为0-2047，科学计数法E可能为负，规定E在存入时必须加上一个中间数，8位的E中间数是127，11位是1023



```c
float a = 5.5;
//101.1 = (-1)^0*1.011*2^2
//s=0,E=(2+127=)129,M=1.011
//0100 0000 1011 0000 0000 0000 0000 0000
//0x40b00000
```

![image-20230814090605376](C:\Users\cyl\AppData\Roaming\Typora\typora-user-images\image-20230814090605376.png)

**从内存还原**

\>E不为全0或全1:按照原来的方式，还原时E-127，M补齐前面的1

\>E为全0：E=1-126(1-1023),M不用补齐，表示无限接近0的数字

\>E全1：E=128，表示正负无穷大的数字



```c
//前面的例题
int n=9;
//00000000000000000000000000001001
float* p=(float*)&n;
printf("%d\n",n);
printf("%f\n",*p);
*p=9.0;//1001.0=(-1)^0+1.001*2^3
//0 10000010 00100000000000000000000
printf("%d\n",n);//1091567616
printf("%f\n",*p);
```

